---
title: "Wasmer takes WebAssembly libraries mainstream with WAI"
excerpt: "Import WebAssembly libraries just like any other dependency in your project"
date: "2022-11-25T12:00:00.000Z"
coverImage: "/images/blog/use-wai.png"
author: Michael Bryan
published: false
---

Integrating with other languages and distributing binaries has always raised the WebAssembly's barrier to entry for the average developer, and at Wasmer our goal is to make trivial creating universal libraries that work anywhere.

Today we are happy to announce WAI - WebAssembly Interfaces along with its integration in WAPM, the WebAssembly Package Manager, and the packager: [wasmer-pack](https://github.com/wasmerio/wasmer-pack).

WAI builds on top of the official WebAssembly Interface Types specification, and itâ€™s first working implementation: `wit-bindgen`.

> Note: Unfortunately, the maintainers behind `wit-bindgen` [didnâ€™t want to add support](https://github.com/bytecodealliance/wit-bindgen/issues/306) for [Wasmer upstream](https://github.com/bytecodealliance/wit-bindgen/pull/173). [As we previously coined the `wai` extension](https://medium.com/wasmer/introducing-webassembly-interfaces-bb3c05bc671), we decided to reuse this name for the WebAssembly Interfaces project (think of WAI as WASI without the â€œSystemâ€!). We will be very happy to merge the changes upstream if the `wit-bindgen` maintainers change opinion on supporting Wasmer in the future!

The WAI addition to the [WebAssembly Package Manager](https://wapm.io/) streamlines the way developers use WebAssembly in their applications by automatically generating installable packages for your language of choice.

![/images/blog/use-wai.png](/images/blog/use-wai.png)

In fact, you can see it in action right now with the vscode-wasm plugin, used by more than 92 thousand developers worldwide!

## How Do I Create a Universal WebAssembly Library with Rust and WAI?

Everything revolves around WAI files.

These define the **W**eb**A**ssembly **I**nterfaces your library will expose, and from there our tooling will generate some glue code that makes it easier to implement.

First, create a new Rust project and add [the `wai-bindgen-rust` crate](https://lib.rs/wai-bindgen-rust) as a dependency.

```
$ cargo new --lib tutorial-01
$ cd tutorial-01
$ cargo add wai-bindgen-rust
```

Now, let's define a WAI file that lets us add two floating point numbers.

```
// calculator.wai

/// Add two numbers.
add: func(a: float32, b: float32) -> float32
```

We can use the `wai_bindgen_rust::export!()` macro to "export" this interface (i.e. make it available to some host application).

```rust
// src/lib.rs

// generate the WAI glue code under the `calculator` module
wai_bindgen_rust::export!("calculator.wai");

// Create a type to attach our functionalty to
struct Calculator;

// Implement the trait generated by our glue code
impl crate::calculator::Calculator for Calculator {
	fn add(a: f32, b: f32) -> f32 { a + b }
}

```

ðŸ’¡ You can use `cargo expand` to see the generated code and the `Calculator` trait's definition (`cargo install cargo-expand`).

### Letâ€™s publish it!

Publishing requires installing `wapm` with [the Wasmer installer](https://docs.wasmer.io/ecosystem/wapm/getting-started) and the [`cargo wapm`](https://github.com/wasmerio/cargo-wapm)  helper installed (`cargo install cargo-wapm`). If you haven't already, make sure to run `wapm login` to log into your WAPM account (don't forget to [sign up][sign-up] if you haven't already).

Now we're set up, we'll need to update `Cargo.toml` so this package can be published to WAPM.

```toml
# Cargo.toml
[package]
name = "tutorial-01"
version = "0.1.0"
description = "A simple calculator"

[package.metadata.wapm]
namespace = "<YOUR_USERNAME>"  # The namespace to publish it to
abi = "none" # How to compile the crate. "none" is "wasm32-unknown-unknown"
bindings = { wai-version = "0.2.0", exports = "calculator.wai" }
```

Now we need to tell the Rust compiler to generate a `cdylib` ("C-compatible
dynamic library"). It's also a good idea to add the `rlib` crate type so
integration tests can import the library as a Rust dependency.


```toml
# Cargo.toml
[lib]
crate-type = ["cdylib", "rlib"]
```

And publish!

```console
$ cargo wapm
```

*Note: WAI also works with other languages, such as C or C++. If you want to publish packages to wapm with it, you will need to use `wapm publish` instead of `cargo wapm`.*

## Consuming WAPM Packages in your codebase

Let's add this `wai/tutorial-01` package to a JavaScript project.

First, we'll need to create a new JavaScript package and add the `wai/tutorial-01` package as a dependency.

```console
$ wasmer add --yarn wai/tutorial-01
```

This runs `yarn add` under the hood. Depending on the project, you might use the `--npm` flag to do `npm install` or `--pip` for `pip install`.

Now, let's create a script.

```jsx
import { bindings } from "wai/tutorial-01";

async function main() {
	const calculator = await bindings.calculator();
	const four = calculator.add(2, 2);
	console.log("2 + 2 =", four);
}

main();
```

Or, if you want to do it in python:

```console
$ wasmer add --pip wai/tutorial-01
```

```python
from tutorial_01 import bindings

calculator = bindings.calculator()
print("2+2 = ", calculator.add(2.0, 2.0))
```

## What's Next?

If you've been hesitant to use WebAssembly because it's hard to get started, go ahead and check out [our tutorial series](https://wasmerio.github.io/wasmer-pack/user-docs/tutorial/01-hello-world.html)!

WAPM uses the [Wasmer Pack](https://github.com/wasmerio/wasmer-pack) project to generate these native packages. Feel free to browse the source code, or create tickets on the issue tracker if you have any questions.

We'd love to hear from projects looking to integrate WAPM packages into their own apps. If this sounds like you, reach out [on Slack](https://slack.wasmer.io/), by [email](mailto:engineering@wasmer.io), or the Wasmer Pack issue tracker, and we'll help you get started.

[sign-up]: https://wapm.io/signup
